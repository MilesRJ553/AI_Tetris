using WindowsInput;
using WindowsInput.Native;
using System;

class BOARD_HANDLER
{

    /* =============== Class Attributes =============== */
    private E_CELL_STATUS[,] gameBoard = new E_CELL_STATUS[20, 10];


    /* =============== Constructors =============== */

    public BOARD_HANDLER()
    {
        // Iterate through each cell of the gameBoard
        for (int row = 0; row < this.gameBoard.GetLength(0); ++row)
        {
            for (int col = 0; col < this.gameBoard.GetLength(1); ++col)
            {
                // Set each cell as empty
                this.gameBoard[row, col] = E_CELL_STATUS.EMPTY;
            }
        }
    }


    public void boardHandlingMain(bool[,] uiGameBoard)
    {
        compareGameBoards(uiGameBoard);
        clearFullRows();
    }

    /// <summary>
    /// Updates the gameBoard using a 2D boolean array generated by UI_HANDLER.getGameGrid
    /// Relies on row completion being handles seperately (inted to be handled on spacebar down)
    /// </summary>
    /// <param name="uiGameBoard"></param>
    private void compareGameBoards(bool[,] uiGameBoard)
    {
        // Declaring local variables
        E_CELL_STATUS cellStatus;
        bool uiCellStatus;

        //Check the argument: uiGameBoard has the correct dimensions
        if (uiGameBoard.GetLength(0) != gameBoard.GetLength(0) || uiGameBoard.GetLength(1) != gameBoard.GetLength(1))
        {
            Console.WriteLine("================\nERROR: Printing uiGameBoard\n================");
            MAIN.printGameBoard(uiGameBoard);
            throw new Exception("uiGameBoard should have the dimension [20,10]");
        }

        //  Iterate through each cell of the grid
        for (int row = 0; row < uiGameBoard.GetLength(0); ++row)
        {
            for (int col = 0; col < uiGameBoard.GetLength(1); ++col)
            {
                cellStatus = this.gameBoard[row, col];
                uiCellStatus = uiGameBoard[row, col];

                if (!uiCellStatus) // If the cell is empty in the UI, reflect that in memory
                {
                    this.gameBoard[row, col] = E_CELL_STATUS.EMPTY;
                }
                else if (cellStatus != E_CELL_STATUS.SETTLED) // If the cell is not empty in the UI and isn't settled in memory, set it to falling in memory
                {
                    this.gameBoard[row, col] = E_CELL_STATUS.FALLING;
                }
            }
        }
    }

    /// <summary>
    /// Sets all falling pieces to settled
    /// </summary>
    public void setFallingSettled()
    {
        // Declare local variables
        E_CELL_STATUS cellStatus;

        // Iterate through each cell of the gameBoard
        for (int row = 0; row < this.gameBoard.GetLength(0); ++row)
        {
            for (int col = 0; col < this.gameBoard.GetLength(1); ++col)
            {
                cellStatus = this.gameBoard[row, col];

                // Updates the cell if its status is falling
                if (cellStatus == E_CELL_STATUS.FALLING)
                {
                    this.gameBoard[row, col] = E_CELL_STATUS.SETTLED;
                }

            }
        }
    }

    private void clearFullRows()
    {
        // Declare local variables
        bool rowComplete;
        int col;

        // Iterate through each row
        for (int row = 0; row < this.gameBoard.GetLength(0); ++row)
        {
            rowComplete = true;
            col = 0;
            // Iterates through a row of cells until it finds an empty cell
            while (col < this.gameBoard.GetLength(1) && rowComplete)
            {
                if (this.gameBoard[row, col] != E_CELL_STATUS.SETTLED)
                {
                    rowComplete = false; // Sets the rowComplete flag to false if there are any unsettled cells
                }
                ++col;
            }
            if (rowComplete)
            {
                clearRow(row);
            }
        }
    }

    /// <summary>
    /// Deletes a row from the gameBoard and moves down all rows above it
    /// </summary>
    /// <param name="rowNum"></param>
    private void clearRow(int rowNum)
    {
        // Iterates from rowNum up to the top of the game Board (except the top row)
        for (int row = rowNum; row > 0; --row)
        {
            for (int col = 0; col < this.gameBoard.GetLength(1); col++)
            {
                // Sets each cell to the value of the cell above
                this.gameBoard[row, col] = this.gameBoard[row - 1, col];
            }
        }

        // Delete top row
        for (int col = 0; col < this.gameBoard.GetLength(1); col++)
        {
            this.gameBoard[0, col] = E_CELL_STATUS.EMPTY;
        }
    }


    /* =============== Debug Methods =============== */
    public E_CELL_STATUS[,] getGameBoard()
    {
        return this.gameBoard;
    }

    public void printGameBoard()
    {
        E_CELL_STATUS cellStatus;
        String boardOutput = "";

        for (int row = 0; row < this.gameBoard.GetLength(0); ++row)
        {
            for (int col = 0; col < this.gameBoard.GetLength(1); ++col)
            {
                cellStatus = this.gameBoard[row, col];
                boardOutput = boardOutput + "|";
                switch (cellStatus)
                {
                    case E_CELL_STATUS.EMPTY:
                        boardOutput = boardOutput + " |";
                        break;
                    case E_CELL_STATUS.FALLING:
                        boardOutput = boardOutput + "F|";
                        break;
                    case E_CELL_STATUS.SETTLED:
                        boardOutput = boardOutput + "S|";
                        break;
                }
            }
            boardOutput = boardOutput + Environment.NewLine;
        }

        boardOutput = boardOutput + Environment.NewLine;
        boardOutput = boardOutput + Environment.NewLine;
        boardOutput = boardOutput + ("=  =  =  =  =  =  =  =  =  =");
        boardOutput = boardOutput + Environment.NewLine;
        boardOutput = boardOutput + Environment.NewLine;
        
        Console.WriteLine(boardOutput);
    }

}